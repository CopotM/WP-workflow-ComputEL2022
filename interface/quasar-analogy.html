<DOCTYPE html>
<html>
  <!--
    WARNING! Make sure that you match all Quasar related
    tags to the same version! (Below it's "@2.5.0")
  -->

  <head>
	<meta charset="utf-8"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons" rel="stylesheet" type="text/css">
    <link href="https://cdn.jsdelivr.net/npm/quasar@2.5.0/dist/quasar.prod.css" rel="stylesheet" type="text/css">

	<style>
	.mainpanel {
		display : flex;
		flex-direction : row;
		gap : 30px;
		margin : 30px;
	}
	.leftpanel {
		display : flex;
		flex-direction : column;
		flex : 3;
	}
	.rightpanel {
		display : flex;
		flex-direction : column;
		flex : 3;
	}
	</style>
  </head>

  <body>
    <!-- example of injection point where you write your app template
    -->
  <div id="app">
  	<q-bar>
      <div class="cursor-pointer non-selectable">
        File
        <q-menu>
          <q-list dense style="min-width: 100px">
            <q-item clickable v-close-popup v-on:click="loadState()">
              <q-item-section>Load state...</q-item-section>
            </q-item>
            <q-item clickable v-close-popup v-on:click="saveState()">
              <q-item-section>Save state...</q-item-section>
            </q-item>
          </q-list>
        </q-menu>
      </div>
      <q-dialog v-model="showFileChooser" persistent>
        <q-card style="min-width: 350px">
          <q-card-section>
            <div class="h6">Choose file:</div>
          </q-card-section>
          <q-card-section class="q-pt-none">
            <q-file label="Load..." v-model=fileToLoad></q-file>
          </q-card-section>
          <q-card-actions align="right" class="text-primary">
         <q-btn flat label="Cancel" v-close-popup></q-btn>
          <q-btn flat label="Upload" v-on:click="handleLoad()" v-close-popup>
          </q-btn>
       </q-card-actions>
        </q-card>
      </q-dialog>
    </q-bar>
    <div class="mainpanel">
    <div class="leftpanel">
	  <strong>Analogies</strong>
	  <analogy-browser
		v-bind:lexinfo="lexicalInfo"
		v-bind:corpus="corpus"
		v-bind:words="words"
		v-bind:analogies="analogies"></analogy-browser>
	</div>
	<div class="rightpanel">
	  <strong>Lexicon browser</strong>
	  <lexicon-browser
		v-bind:lexinfo="lexicalInfo"
		v-bind:corpus="corpus"
		v-bind:words="words"
		v-bind:analogies="analogies"></lexicon-browser>
	</div>
  </div>
  </div>

    <!-- Add the following at the end of your body tag -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quasar@2.5.0/dist/quasar.umd.prod.js">
</script>

    <script>
      /*
        Example kicking off the UI. Obviously, adapt this to your specific needs.
        Assumes you have a <div id="q-app"></div> in your <body> above
       */
      const app = Vue.createApp({
		  mounted: function() {
			  //this.corpus["foo"] = ["snoo", "moo"];
			  this.init();
		  },
		  data: function () { return {
			  corpus : {},
			  //word -> { lexItems : [ { name, concordance, id } ] }
			  lexicalInfo : {},
			  // [ {id, name, [members]} ]
			  analogies : [],
			  search1 : "",
			  search2 : "",
        showFileChooser : false,
        fileToLoad : "",
        fnord : ""
		  }; },
		  methods: {
        compressState : function ()
        {
          //serializing is very frustrating because json writes out the
          //data structures densely without using references
          compressedInfo = {}
          function compressInfo (info)
          {
            return { word : info.word, name : info.name, id : info.id,
                     examples : null, selections : info.selections };
          }
          for (const [key,val] of Object.entries(this.lexicalInfo))
          {
            compressedInfo[key] = val.map(compressInfo);
          }

          compressedAnalogies = []
          function compressMem (mem)
          {
            return { left : [mem.left[0], mem.left[1].id],
                     right : [mem.right[0], mem.right[1].id] }
          }
          function compressAnalogy (ana)
          {
            return { id : ana.id, name : ana.name, provenance : ana.provenance,
              selections : ana.selections, approved : ana.approved,
              members : ana.members.map(compressMem) }
          }
          compressedAnalogies = this.analogies.map(compressAnalogy);

          return { lexicalInfo : compressedInfo, analogies : compressedAnalogies }
        },
        decompressState : function (compressed)
        {
          lex = compressed.lexicalInfo;
          for(const [word, entries] of Object.entries(lex))
          {
            for(var entry of entries)
            {
              entry.examples = this.corpus[word];
            }
          }
          compressedAna = compressed.analogies;
          function findSplit(member, lexicalInfo)
          {
            word = member[0];
            splitID = member[1];
            // console.log("finding split " + word + splitID);
            // console.log(lexicalInfo);
            splits = lexicalInfo[word].filter( (xx) => (xx.id == splitID));
            target = splits[0];
            return target;
          }
          function decompressMem (mem)
          {
            return { left : [mem.left[0], findSplit(mem.left, lex) ],
                     right : [mem.right[0], findSplit(mem.right, lex)] };
          }
          function decompressAnalogy (ana)
          {
            return { id : ana.id, name : ana.name, provenance : ana.provenance,
              selections : ana.selections,
              approved : ana.approved,
              members : ana.members.map(decompressMem) }
          }
          analogies = compressedAna.map(decompressAnalogy);

          return { lexicalInfo : lex, analogies : analogies }
        },
			  // https://stackoverflow.com/questions/59243445/read-and-display-json-data-from-external-file-in-vue-js
			  loadJSON(filename, callback)
			  {
				  var xobj = new XMLHttpRequest();
				  xobj.overrideMimeType("application/json");
				  xobj.open('GET', filename, true)
				  xobj.onreadystatechange = function () {
					  if (xobj.readyState == 4 && xobj.status == "200") {
						  // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
						  callback(xobj.responseText);
					  }
				  };
				  xobj.send(null);
			  },
			  init()
			  {
				  let that = this
				  that.loadJSON("./en-gum-verb.json", function (response) {
					  // Parse JSON string into object
					  var data = JSON.parse(response);
					  that.corpus = data;
				  });
			  },
			  saveState : function ()
			  {
			  	console.log("trying to save state")
			  	//state = { lexicalInfo : this.lexicalInfo, analogies : this.analogies };
          state = this.compressState();
			  	dataStr = JSON.stringify(state);
    			dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    			exportFileDefaultName = 'data.json';

    			linkElement = document.createElement('a');
    			linkElement.setAttribute('href', dataUri);
    			linkElement.setAttribute('download', exportFileDefaultName);
    			linkElement.click();
			  },
			  loadState : function ()
			  {
			  	console.log("trying to load state")
          this.showFileChooser = true;
        },
        handleLoad : function ()
        {
          console.log("actually loading");
          console.log(this.fileToLoad);
          let that = this
				  that.loadJSON(this.fileToLoad.name, function (response) {
					  // Parse JSON string into object
					  var data = JSON.parse(response);
            data = that.decompressState(data);
					  that.lexicalInfo = data.lexicalInfo;
            that.analogies = data.analogies;
          });
        },
		  },
		  computed: {
			  words: function ()
			  {
				  return Object.keys(this.corpus).map(
					  function(element, index) {
						  return { id : index, text : element }; } )
			  }
		  }
        });

      app.component("clickable-item", {
          props: ["text"],
          template: `<q-item clickable v-ripple
            v-on:click=clicked>
           {{ text }}
          </q-item>`,
          methods: {
              clicked : function ()
              {
                  this.$emit('select', this);
              }
          }
      });

	  app.component("searchable-menu", {
        props: ["items", "value"],
        data: function() {
            return {
            "searchFor" : ""
            };
         },
        template: `<div>
                    <input v-model="searchFor" placeholder="Search..."
                     v-on:keyup.enter="select"/>
                    <div style="max-height:150px;overflow:scroll">
                      <q-expansion-item label="Show list...">
                      <q-list
                       :dense>
                       <clickable-item
                         v-for="word in visibleItems"
                         v-bind:text="word.text"
                         v-bind:key="word.id"
                         v-on:select="select"
                        />
                      </q-list>
                      </q-expansion-item>
                    </div>
                  </div>`,
          methods:
		  {
			  select : function (clickable)
			  {
				  if (clickable instanceof KeyboardEvent)
				  {
					  console.log("handle enter key");
					  for(var ii = 0; ii < this.items.length; ii++)
					  {
						  if (this.items[ii].text == this.searchFor)
						  {
							  console.log("dispatched");
							  this.$emit('setvalue', this.searchFor);
						  }
					  }
				  }
				  else
				  {
					  console.log("clicked " + clickable.text);
					  this.$emit('setvalue', clickable.text);
				  }
			  }
          },
        computed: {
			visibleItems : function ()
			{
				getChecker = function (obj)
				{
					return function (item) {
						return item.text.startsWith(obj.searchFor);
                    }
				}
				return this.items.filter(getChecker(this)).sort(
					function(xx, yy){ return xx.text > yy.text; } );
			}
		}
      });

	  app.component("lexical-entry-picker", {
		  props: ["word", "corpus", "lexinfo", "lexsplit"],
		  template: `<div v-if="word != '' && word in corpus">
                     <div>
                      <q-btn color="primary" label="Lexical split">
                       <q-menu>
                        <q-list>
                         <q-item clickable v-close-popup
                           v-for="lex in lexicalEntries"
                           v-bind:lex="lex"
                           v-on:click="chose(lex)">
                          <q-item-section>
                            {{lex.name}}
                          </q-item-section>
                         </q-item>
                        </q-list>
                       </q-menu>
                      </q-btn>
                      <input
                       v-if="lexsplit != undefined"
                       v-model="lexsplit.name"></input>
                     </div>
                     </div>`,
		  data : function ()
		  {
			  return { };
		  },
		  methods : {
			  chose : function (event)
			  {
				  // console.log("you clicked " + event.name + " id " + event.id);
				  if (event.id == undefined)
				  {
					  // console.log("my word is " + this.word);
					  if (this.word == "" || !(this.word in this.corpus))
					  {
						  //should be made inaccessible from interface
						  console.log("cannot split null word");
					  }
					  else
					  {
						  //user created new lexical split
						  console.log("trying to split " + this.word);
						  this.$emit("update", this.newLexicalSplit());
					  }
				  }
				  else
				  {
					  //existing split
					  this.$emit("update", event);
				  }
			  },
			  newLexicalSplit : function ()
			  {
				  if (!(this.word in this.lexinfo))
				  {
					  this.lexinfo[this.word] = [];
				  }
				  nextID = this.lexinfo[this.word].length + 1;
				  name = this.word + "_" + nextID;
				  exes = this.corpus[this.word];
				  nExe = exes.length;
				  lexsplit = { word : this.word, name : name,
							         examples : exes,
							         id : nextID,
   							       selections : Array(nExe).fill(true)
							 };

				  // console.log("created new split: " + lexsplit);

				  this.lexinfo[this.word].push(lexsplit);
				  return lexsplit;
			  },
		  },
		  computed : {
			  lexicalEntries : function ()
			  {
				  // console.log("getting lex entries for menu");
				  var res = this.lexinfo[this.word];
				  if (res == undefined)
				  {
					  res = [];
				  }
				  // else
				  // {
				  // 	  res = res.filter(item => item.id != undefined);
				  // }
			      // res.push({name : "New lexical split",
				  // 			concordance : undefined,
				  // 			id : undefined});
				  // console.log("menu " + res);
				  return res.concat([{name : "New lexical split",
									  concordance : undefined,
									  id : undefined}]);
			  }
		  },
		  watch : {
			  word : function (newWord, oldWord)
			  {
				  if (newWord != oldWord)
				  {
					  this.$emit("update", undefined);
				  }
			  }
		  }
	  });

	  app.component("lexical-entry-table", {
		  props: ["word", "corpus", "lexinfo", "lexsplit"],
		  template: `<div v-if="word != '' && word in corpus">
                      <q-table
                        v-bind:rows="rows"
                        v-bind:columns="columns"
                        v-bind:row-key="row => row.index"
                        v-on:row-click="selectRow"
                        v-model:pagination="pagination"
                        dense
                        :rows-per-page-options=5
                        virtual-scroll>
                      <concordance
                       v-bind:corpus=corpus
                       v-bind:lexsplit=lexsplit>
                      </concordance>
                     </div>`,
		  methods : {
			  selectRow : function (event, row)
			  {
				  console.log("chose lexical split");
				  console.log(row);
          targetSplit = undefined;
          for (var ii = 0; ii < this.lexicalEntries.length; ii++)
          {
            if (this.lexicalEntries[ii].name == row.name)
            {
              this.$emit("update", this.lexicalEntries[ii]);
              return;
            }
          }

          //an error
          console.log("can't find lexical entry!");
			  },
		  },
		  computed : {
			  lexicalEntries : function ()
			  {
				  console.log("getting lex entries for table");
				  var res = this.lexinfo[this.word];
				  if (res == undefined)
				  {
					  res = [];
				  }
				  return res;
			  },
			  rows : function ()
			  {
				  formatRow = function (row, index)
				  {
					  nExes = row.selections.reduce((xx, yy) => (xx + yy));
					  return {
						  index : index,
						  name : row.name,
						  nExes : nExes
					  };
				  }
				  return this.lexicalEntries.map(formatRow);
			  },
			  columns : function ()
			  {
				  const columns = [
					  { name : "index", label : "#", field : "index"},
					  { name : "name", label : "Name", field : "name"},
					  { name : "nExes", label : "(#positive)", field :
						"nExes"},
				  ];
				  return columns;
			  }
		  },
		  watch : {
			  word : function (newWord, oldWord)
			  {
				  if (newWord != oldWord)
				  {
					  this.$emit("update", undefined);
				  }
			  }
		  }
	  });

	  app.component("concordance", {
		  props: ["corpus", "lexsplit"],
		  template: `<div v-if="lexsplit != undefined">
                       <q-table
                         v-bind:rows="rows"
                         v-bind:columns="columns"
                         v-bind:row-key="row => row.index"
                         v-model:pagination="pagination"
                         v-model:selected="selections"
                         v-on:update:selected="changed"
                         style="height:200px"
                         dense
                         selection="multiple"
                         :rows-per-page-options="[0]"
                         virtual-scroll
                         hide-header
                         hide-bottom>
                       </q-table>
                     </div>`,
		  computed : {
			  word : function ()
			  {
				  return this.lexsplit.word;
			  },
			  examples : function ()
			  {
				  return this.lexsplit.examples;
			  },
			  rows : function ()
			  {
				  // console.log("getting rows for concordance")
          // console.log(this.lexsplit)
          // console.log(this.lexsplit.examples)
				  formatRow = function (example, index, word)
				  {
					  wordIndex = example.map(xx => xx.toLowerCase()).indexOf(word);
            // console.log("finding example " + word + " in " + example.map(xx => xx.toLowerCase()))
            // console.log("-> " + wordIndex)
					  len = example.length;
					  return { index : index,
							   lhs : example.slice(0, wordIndex).join(" "),
							   word : word,
							   rhs : example.slice(
								   wordIndex + 1, len).join(" ")
							 };
				  }

				  rows = [];
				  for(var ii = 0; ii < this.examples.length; ii++)
				  {
					  rows.push(formatRow(this.examples[ii], ii, this.word));
				  }
				  // console.log("selected status: "+this.lexsplit.selections);
				  return rows;
			  },
			  columns : function ()
			  {
				  // console.log("getting columns");
				  const columns = [
					  { name : "index", label : "#", field : "index"},
					  { name : "lhs", label : "lhs", field : "lhs",
						align: "right",
						style : "max-width:100px;overflow:hidden;direction:rtl",
					    headerStyle: "max-width:100px"},
					  { name : "word", label : "word", field : "word" },
					  { name : "rhs", label : "rhs", field : "rhs",
						align : "left",
						style : "max-width:100px;overflow:hidden",
					    headerStyle: "max-width:100px"},

				  ];
				  return columns;
			  },
			  selections : function ()
			  {
				  var result = [];
				  for(var ii = 0; ii < this.examples.length; ii++)
				  {
					  if (this.lexsplit.selections[ii])
					  {
						  result.push(this.rows[ii]);
					  }
				  }
				  return result;
			  }
		  },
		  methods : {
			  changed : function (event)
			  {
				  var indicators = Array(event.length).fill(false);
				  for (var ii = 0; ii < event.length; ii++)
				  {
					  evI = event[ii].index;
					  indicators[evI] = true;
				  }
				  this.lexsplit.selections = indicators;
				  this.$emit("update", indicators);
			  }
		  }
	  });

    // <div style="margin:30px;max-width:250px">
    //    <q-item><q-item-section avatar>
    //    <q-badge color="primary">Max dist.</q-badge></q-item-section>
    //    <q-item-section>
    //    <q-slider v-model=skips :min="1" :max="maxskips"
    //    label label-always>
    //    </q-item-section>
    // </div>

	  app.component("paradigm-viewer", {
		  props: ["word", "corpus", "lexinfo", "lexsplit", "analogies"],
		  template: `<div style="margin:10px" v-if="lexsplit != undefined">
                        <q-table
                         v-bind:rows="rows"
                         v-bind:columns="columns"
                         v-bind:row-key="row => row.index"
                         :pagination="pagination"
                         dense
                         :rows-per-page-options="[0]"
                         virtual-scroll>
                       </q-table>
                    </div>`,
      data : function ()
      {
          return {
            pagination : {
              sortBy : "distance",
              descending : false,
              rowsPerPage : 10,
            },
            skips : undefined,
            maxskips : undefined,
        }
      },
		  methods : {
			  relatives : function ()
			  {
				  // console.log("getting relatives " + skips +
					// 		  " steps from " + this.lexsplit.name);
				  seen = {};
          seen[this.lexsplit.name] = [];
          let skips = this.skips;
          if (this.skips == this.maxskips)
          {
            skips = undefined;
          }
				  this.getRelatives(this.lexsplit.name, skips, seen, []);
				  // console.log("termination")
				  // console.log(seen);
          //don't return starting point
          delete seen[this.lexsplit.name];
				  return seen;
			  },
			  getRelatives : function (split, skips, seen, path)
			  {
				  // console.log(":: getting relatives " + skips +
					// 		  " " + split);
				  if (skips == 0)
				  {
					  return;
				  }

				  let fromHere = this.analogiesByWord[split];
          if (fromHere == undefined)
          {
            return;
          }
				  let analogies = Object.values(fromHere);
          // console.log("considering " + analogies.length +" items here")
				  for(var ii = 0; ii < analogies.length; ii++)
				  {
					  analogyI = analogies[ii];
            // console.log("at depth " + skips + " visit " + analogyI.left + " " + analogyI.right)

					  let other = ((analogyI.left == split) ?
							   analogyI.right : analogyI.left);
					  let pathTo = path.concat([{ analogy : analogyI.name, destination : other }])
					  // console.log("computed path at depth " + skips + " to " + other);
					  //console.log(pathTo);
					  if (!(other in seen) || seen[other].length > pathTo.length)
					  {
						  // console.log("accepted");
						  seen[other] = pathTo;
						  this.getRelatives(other, skips - 1, seen, pathTo);
					  }
				  }
			  },
		  },
		  computed : {
			  analogiesByWord : function ()
			  {
				  var res = {};
				  for (var ii = 0; ii < this.analogies.length; ii++)
				  {
					  aI = this.analogies[ii];
            if (!aI.approved)
            {
              continue;
            }

					  for (var jj = 0; jj < aI.members.length; jj++)
					  {
              if(!aI.selections[jj])
              {
                continue;
              }
						  mem = aI.members[jj];
						  left = mem.left[1].name;
						  right = mem.right[1].name;

              if(left == right)
              {
                continue; //do not allow loops
              }

						  if (!(left in res))
						  {
							  res[left] = [];
						  }
						  if (!(right in res))
						  {
							  res[right] = [];
						  }

						  const desc = { name : aI.name,
                     analogy : aI,
										 left : left, right : right
									   };
						  res[left].push(desc);
						  res[right].push(desc);
					  }
				  }
          // console.log("printing abw");
          // console.log(res);

				  return res;
			  },
			  rows : function ()
			  {
				  formatRow = function (relative, index)
				  {
            nn = relative[1].length;
            relationStr = "";
            for (var ii = 0; ii < nn; ii++)
            {
              ana = relative[1][ii].analogy;
              dest = relative[1][ii].destination;
              if (ii < nn - 1)
              {
                relationStr += ana + "->" + dest + ", ";
              }
              else
              {
                relationStr += ana;
              }
            }
					  return { index : index,
							   relative : relative[0],
                 distance : relative[1].length,
							   relation : relationStr };
				  }
				  return Object.entries(this.relatives(this.skips)).map(formatRow);
			  },
			  columns : function ()
			  {
				  const columns = [
					  { name : "index", label : "#", field : "index"},
					  { name : "relative", label : "Relative",
						field : "relative"},
            { name : "distance", label : "Dist", field : "distance"},
					  { name : "relation", label : "Relation",
						field : "relation"},
				  ];
				  return columns;
			  },
		  }
	  });

	  app.component("lexicon-browser", {
		  props: ["lexinfo", "words", "corpus", "analogies"],
		  template: `<div>
                      <searchable-menu
                       v-bind:items="words"
                       v-bind:value="display"
                       v-on:setvalue="display = $event">
                      </searchable-menu>
                      <lexical-entry-table
                       v-bind:word="display"
                       v-bind:corpus="corpus"
                       v-bind:lexinfo="lexinfo"
                       v-bind:lexsplit="lexsplit"
                       v-on:update="lexsplit=$event">
                      </lexical-entry-table>
                      <p v-if="lexsplit != undefined" style="margin:10px"><strong>
                        Viewing lexical split:
                        {{lexsplit.name}}</strong>
                      <q-expansion-item label="Edit concordance...">
                      <concordance
                       v-bind:corpus=corpus
                       v-bind:lexsplit=lexsplit>
                      </concordance>
                      </q-expansion-item></p>
                      <paradigm-viewer
                       v-bind:word="display"
                       v-bind:corpus="corpus"
                       v-bind:lexinfo="lexinfo"
                       v-bind:lexsplit="lexsplit"
                       v-bind:analogies="analogies">
                     </div>`,
		  data : function ()
		  {
			  return { display : "", lexsplit : undefined };
		  }
	  });

	  app.component("analogy-browser", {
		  props: ["lexinfo", "words", "corpus", "analogies"],
		  template: `<div>
                      <q-table
                         v-bind:rows="rows"
                         v-bind:columns="columns"
                         v-bind:row-key="row => row.index"
                         v-on:row-click="selectRow"
                         v-model:pagination="pagination"
                         style="height:200px"
                         v-model:selected="selected"
                         v-on:update:selected="changed"
                         dense
                         selection="multiple"
                         :rows-per-page-options="[0]"
                         virtual-scroll>
                       </q-table>
                        <analogy-creator
                         v-bind:lexinfo="lexinfo"
                         v-bind:words="words"
                         v-bind:corpus="corpus"
                         v-bind:analogies="analogies"
                         v-bind:currentid="currentAnalogy"
                         v-on:update="updateCurrent($event)">
                        </analogy-creator>
                    </div>`,
		  data : function ()
		  {
			  return { currentAnalogy : undefined };
		  },
		  methods : {
        changed : function (event)
        {
          for(var ii = 0; ii < this.analogies.length; ii++)
          {
            this.analogies[ii].approved = false;
          }
          for (var ii = 0; ii < event.length; ii++)
          {
            evI = event[ii].index;
            rowAna = this.analogies.filter(xx => (xx.id == evI))[0];
            rowAna.approved = true;
          }
          // this.$emit("update", indicators);
        },
			  selectRow : function (event, row)
			  {
				  console.log("setting curr analogy to " + row.index);
				  this.currentAnalogy = row.index;
			  },
			  updateCurrent : function (event)
			  {
				  console.log("caught update from analogy creator");
				  console.log(event);
				  this.currentAnalogy = event;
			  }
		  },
		  computed : {
        selected : function ()
        {
          var result = [];
          for(var ii = 0; ii < this.rows.length; ii++)
          {
            index = this.rows[ii].index;
            if (index != undefined)
            {
              rowAna = this.analogies.filter(xx => (xx.id == index))[0];
              if (rowAna.approved)
              {
                result.push(this.rows[ii]);
              }
            }
          }
          return result;
        },
			  rows : function ()
			  {
				  formatRow = function (analogy, index)
				  {
					  nMembers = analogy.selections.filter(xx => xx).length
					  return {
						  index : analogy.id,
						  name : analogy.name,
              provenance : analogy.provenance,
						  members : nMembers,
					  };
				  }
				  return this.analogies.map(formatRow).concat(
					  [{ index : undefined, name : "Create new", approved : false,
						 members : [] }]);
			  },
			  columns : function ()
			  {
				  const columns = [
					  { name : "index", label : "#", field : "index"},
					  { name : "name", label : "name", field : "name"},
            { provenance : "provenance", label : "source", field : "provenance" },
					  { name : "members", label : "Size", field : "members"}
				  ];
			  }
		  },
	  });

	  app.component("analogy-creator", {
		  props: ["lexinfo", "words", "corpus", "analogies", "currentid"],
		  template: `<div style="margin:10px">
                      <p><strong>Current analogy:
                          {{analogy != undefined ? analogy.name :
                          "new"}}
                         </strong></p>
                      <q-table
                         v-bind:rows="rows"
                         v-bind:columns="columns"
                         v-bind:row-key="row => row.index"
                         selection="multiple"
                         v-model:selected="selected"
                         v-on:update:selected="changed"
                         dense>
                         <template v-slot:body-selection="scope">
                           <q-checkbox dense v-model="scope.selected" />
                        </template>
                       </q-table>
                         <div style="display:flex" class="row">
                          <div class="align-start" style="flex:1">
                            <searchable-menu
                              v-bind:items="words"
                              v-bind:value="word1"
                              v-on:setvalue="word1 = $event">
                            </searchable-menu>
                            <strong>{{word1}}</strong>
                            <lexical-entry-picker
                             v-bind:word="word1"
                             v-bind:corpus="corpus"
                             v-bind:lexinfo="lexinfo"
                             v-bind:lexsplit="lexsplit1"
                             v-on:update="lexsplit1=$event">
                            </lexical-entry-picker>
                          </div>
                          <div class="align-start" style="flex:1">
                            <searchable-menu
                              v-bind:items="words"
                              v-bind:value="word2"
                              v-on:setvalue="word2 = $event">
                            </searchable-menu>
                            <strong>{{word2}}</strong>
                            <lexical-entry-picker
                             v-bind:word="word2"
                             v-bind:corpus="corpus"
                             v-bind:lexinfo="lexinfo"
                             v-bind:lexsplit="lexsplit2"
                             v-on:update="lexsplit2=$event">
                            </lexical-entry-picker>
                          </div>
                        </div>
                      <div class="row flex-center">
                      <input v-model="name"></input>
                      <q-btn v-bind:label="approveOrAdd"
                        text-color="black"
                        v-bind:color="validcolor"
                        v-on:click="approveAdd()">
                      </q-btn>
                      </div>
                     </div>`,
		  data : function ()
		  {
			  return { word1 : "", word2 : "",
					   lexsplit1 : undefined, lexsplit2 : undefined,
					   name : "" };
		  },
		  methods : {
			  approveAdd : function ()
			  {
				  if (this.approveOrAdd == "Approve")
				  {
					  this.approve();
				  }
				  else
				  {
					  this.add();
				  }
			  },
			  add : function ()
			  {
				  console.log("add to analogy");
				  const newWord = {
					  left : [ this.word1, this.lexsplit1 ],
					  right : [ this.word2, this.lexsplit2 ],
				  };
				  this.analogy.members.push(newWord);
          this.analogy.selections.push(true);
			  },
			  approve : function ()
			  {
				  console.log("approve analogy");
				  nextID = this.analogies.length;
				  const headword = {
					  left : [ this.word1, this.lexsplit1 ],
					  right : [ this.word2, this.lexsplit2 ],
				  };
				  const analogy = {
					  id : nextID,
					  name : this.name,
					  members : [ headword ],
            selections : [ true ],
            provenance : "web",
            approved : true,
				  };
				  console.log("created analogy")
				  console.log(analogy);
				  this.analogies.push(analogy);
				  //emit an event to set the analogy of this viewer
				  this.$emit("update", analogy.id);
				  this.reset();
			  },
        changed : function (event)
        {
          var indicators = Array(event.length).fill(false);
          for (var ii = 0; ii < event.length; ii++)
          {
            evI = event[ii].index;
            indicators[evI] = true;
          }
          this.analogy.selections = indicators;
          // this.$emit("update", indicators);
        },
			  reset : function ()
			  {
				  //reset the view environment
				  this.word1 = "";
				  this.word2 = "";
				  this.lexsplit1 = undefined;
				  this.lexsplit2 = undefined;
			  }
		  },
		  computed : {
			  analogy : function ()
			  {
				  console.log("checking current analogy " + this.currentid);
				  if (this.currentid != undefined)
				  {
					  return this.analogies[this.currentid];
				  }
			  },
			  rows : function ()
			  {
				  if (this.analogy == undefined)
				  {
					  return [];
				  }

				  formatRow = function (member, index)
				  {
					  return {
						  index : index,
						  left : member.left[0],
						  leftSplit : member.left[1].name,
						  right : member.right[0],
						  rightSplit : member.right[1].name
					  };
				  }
				  // console.log("mapping rows");
				  // console.log(this.analogy.members);
				  return this.analogy.members.map(formatRow);
			  },
			  columns : function ()
			  {
				  const columns = [
					  { name : "index", label : "#", field : "index"},
					  { name : "left-word", label : "Word A", field : "left"},
					  { name : "left-split", label : "(Lex)",
						field : "leftSplit"},
					  { name : "right-word", label : "Word B",
						field : "right"},
					  { name : "right-split", label : "(Lex)",
						field : "rightSplit"},
				  ];
			  },
        selected : function ()
        {
          if (this.analogy == undefined)
          {
            return [];
          }
          var result = [];
          for(var ii = 0; ii < this.analogy.selections.length; ii++)
          {
            if (this.analogy.selections[ii])
            {
              result.push(this.rows[ii]);
            }
          }
          return result;
        },
  			approveOrAdd : function ()
	  		{
				  return (this.analogy == undefined) ? "Approve" :
					  "Add";
		  	},
			  valid : function ()
			  {
				  return (this.word1 != "" && this.word2 != "" &&
						  this.lexsplit1 != undefined &&
						  this.lexsplit2 != undefined);
			  },
			  validcolor : function ()
			  {
				  return this.valid ? "primary" : "grey";
			  },
			  suggestedName : function ()
		  	{
			   if (this.currentid != undefined)
				  {
					  return this.analogy.name;
				  }
				  if (!this.valid)
				  {
					  return "";
				  }
				  else
				  {
						  return (this.lexsplit1.name + "~" +
								  this.lexsplit2.name);
				  }
			  }
		  },
		  watch : {
			  suggestedName : function(newName, oldName)
			  {
				  this.name = newName;
			  },
			  currentid : function(newid, oldid)
			  {
				  if (newid == undefined)
				  {
					  this.reset();
				  }
			  }
		  }
	  });

      app.use(Quasar)
      app.mount('#app')
    </script>
  </body>
</html>
